ВСЯ информация которую мы получаем от пользователя ВСЕГДА КАРЛ ВСЕГДА
БУДЕТ СТРОКОЙ.
const answer = prompt(`How old are you?`,``);
const answerDefault = prompt(`How old are you?`,`22`);
в обратку прийдут СТРОКИ, даже если пользователь ввёл число.Но можно принудительно
конвертировать в число поставив перед propt "+"
const answerDefault = +prompt(`How old are you?`,`22`);
тогда на выходе будет число


                                    				Интерполяция
//интерполяция. Для её использования необходимо пользоваться `` .
//По сути это удобное использование  переменных в других переменных
let category = `toys`;
console.log(`https://someurl./${category}/5`);//внесение переменных через $

//так же можно интерполировать и любые другие структуры
let user =`Anton`;
alert(`Hi everybody,${user}`);

								isNaN
 let numberOfFilms;

function start()
{   //проверяем на пустую строку, на null(пользователь отменяет действие)и проверяем на то что 
    //пользователь ввёл число для этого есть команда isNaN- если внутри НЕчисло то он вернёт правду
    while(numberOfFilms==``||numberOfFilms=null||isNaN(numberOfFilms))
    {
        numberOfFilms = +prompt(`Сколько фильмов вы просмотрели?`,``);
    }



								trim
//метод trim убирает пробелы вконце и в начале строки, таким образом мы  отфилтруем данные 
    //предоставил нам пользователь. Елси юхверь кинет нам просто кучу пробелом, то он обрежется
    //до пустой строки =``. А мы уже такое исключение отработали
        const a = prompt(`Один из последних просмотренных фильмов?`,``).trim(),
              b = prompt(`На сколько оцените его?`, ``);
        


							call-back function
//что бы фукции вызывались и выполнялись последовательно и существую callback_function
function learnJS(lang, callback)
{
    console.log(`я учу ${lang}`);
    callback();
}

function done()
{
    console.log(`я прошёл этот урок`);
}

learnJS(`JavaScript`,done);

							Деструктуризация объекта
Если по простому  деструктуризация это разбиени объекта на более мелкие. Если у объекта есть свои подобъекты тогда мы можем 
выдернуть его и использовать, не городя огромные формулы перебора элементов через for_in.

const option = {
    name: `test`,
    width: 2048,
    height: 1024,
    colors:{
        border: `black`,
        bg: `red`
    }
};

//мы вытащили их как отдельные переменные и мы можем с ними работать
console.log(border);
						Как узнать количество элементов в объекте
//как узнать количество элементов в объекте
console.log(Object.keys(option));//нам вернётся массив  содержащий тупо ключи.
//но у массива есть свойство length 
console.log(Object.keys(option).length);

                                                работа массивами
                                                const arr = [1, 5, 7, 3, 5, 8];
//тупо удаляет последний элемент в массиве
arr.pop();

console.log(arr);

//добавляем в конец массива элемент
arr.push(55);

console.log(arr);

//есть так же команды для работы с началом массива но они НЕИСПОЛЬЗУЮТСЯ(unshift,shift)
//если мы работаем с началом массива, то индекс остальных элементов начинает меняться
//и подобная переиндексация может занять огромное количество времени, поэтому лучше работать с концом массива
    





                                                массивы / псевдомассивы

                                                
const arr = [1, 5, 7, 3, 5, 8];
//тупо удаляет последний элемент в массиве
arr.pop();

console.log(arr);

//добавляем в конец массива элемент
arr.push(55);

console.log(arr);

//есть так же команды для работы с началом массива но они НЕИСПОЛЬЗУЮТСЯ(unshift,shift)
//если мы работаем с началом массива, то индекс остальных элементов начинает меняться
//и подобная переиндексация может занять огромное количество времени, поэтому лучше работать с концом массива



//мы так же можем перебрать элементы в массиве через for а можем через цикл for_of(работает с массивоподобными сущностями
//массив, строку, псевдомассивы)
//главное надо помнить что fjr_in неработает в массивах
for(let value of arr)
{
    console.log(value);
}




const arr_test = [1, 5, 7, 3, 5, 8];
//и ещё один более менее интересный способ перебора элементв в массиве с помощью forEach(); он принимает в 
//себя целую call-back функцию.В call-back можно максимум поместить 3 переменные.
//1)item - это тот элемент который мы перебираем [1, 5, 7, 3, 5, 8]
//2)i -индекс
//3)arr_link - ссылка на тот массив который мы перебираем
arr_test.forEach(function(item,i,arr_link)
{
    console.log(`Индекс ${i}, элемент ${item} внутри массива ${arr_link}`);
});

//Обычно везде используют forEach(): но иногда используют for_of 
//тк как у for_of есть break; continue;
//так же есть arr_test.mapfunction(); он в отличие от forEach, перебирает И МОДИФИЦИРУЕТ объекты
//arr_test.filter(); по названию понятно чё он делать, например мы можем отфильтровать массив по чётным числам
//for_each просто перебирает массивы, а остальные методы модиифицируют массив

//метод split
// к примеру у нас есть строка полученная от пользователя через разделитель
let str = `Товар_1, Товар_2, Товар_3, Товар_4, Товар_5`;
//в скобочках указывам разделитель(`, `)
const products = str.split(`, `);
//на выходе будет массив
console.log(products);

//так же есть обратная операция ИЗ МАССИВА делаем СТРОКУ, ну малоло мож пользователю надо чёто показать
//внутри указываем разделитель через который они будут выводиться (; )
products_mofifi = products.join(`; `);
console.log(products_mofifi);


//немного странный метод sort(), он всегда сортирует элементы внутри массива как строки, и это может вызвать
//в некоторых случаях странные результаты. Попробуем отсортировать строки
let str_sort = [`Abr`,`Lrb`,`Cdp`,`Tmp`,`Tst`];
let test_str = str_sort.sort();
//массив будет отсортирован в алфавитном порядке
console.log(test_str);



//однако если мы попробуем отсортировать числа
let int_sort = [2,13,26,8,10];
let test_int = int_sort.sort();
//то мы получи какую-то хрень, массив выстроится [10,13,2,26,8]
console.log(test_int);
//а всё потому что он сортирует их как строки

//однако можно заставить sort(), работать с числами правильно. Тк внутри sort() использует алгоритм быстрой сортировки
//то мы можем передать в него шаблон(колбэк функцию)

function compareNum(a,b)
{
    return a-b;
}

// и   теперь пихаем её в sort();
test_int = int_sort.sort(compareNum);
//и вуаля отсортировался правильно от меньшего к большему
console.log(test_int);


//ПСЕВДОМАССИВЫ 
//по сути это элемент который имеет структуру такую же как и массив. Они ооочень часто будут приходить нам со страницы
//от пользователя. Важным отличием псевдомассивов в том что в них нет НИКАКИХ методов, 
//нет метода push(), pop(); forEach()....................




                                                                    //ЗАМЫКАНИЕ
//если по простому то замыкание это когда функция вначале ищет доступные переменные(это могут массивы, объекты......) внутри себя,  а не найдя 
//необходимое обращается к глобальным объектам