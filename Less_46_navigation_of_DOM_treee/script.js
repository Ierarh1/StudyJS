                                                             //как путешествовать по элементам
                                            //скажем стоит  задача, есть элемент и как обратиться 
                                            //к его родителю, или к следующему элементу и уже у них поменять калсс
//мы уже получали элемент body но мы так же можем получить элемент head
console.log(document.body);
console.log(document.head);
//у head  и  у body родителем является html что бы достучаться до него можно обратиться по свойству 
console.log(document.documentElement);


//получение детей элемента например body
//p.s вообще мы получим все ебучие ноды, там переносы строк.... собственно вытащим полностью все узлы
console.log(document.body.childNodes); //получим всевдомассив
//но элементов там будет куда больше чем реально есть, там будет встречаться text - это перенос строки
//то есть грубо говоря этот метод берёт и перебирает весь index.html  с учётом переносов строки

        //разница между DOM-элементами и DOM-узлами
//каждая сущность расположенная в index.html  является УЗЛОМ, но не каждый узел является элементом
//грубо говоря всё что в тёгах это элементы всё остальное узлы

//получение ПЕРВОГО и ПОСЛЕДНЕГО УЗЛА
console.log(document.body.firstChild);//тут будет текстовый узел(перенос строки)
console.log(document.body.lastChild);//тут будут строчка которая подключает наш файл js
//однако если использовать firstElementChild и lastElementChild  то мы будем получать именно элементы а не текстовые ноды


                                                //а теперь поработаем с командами которые позволяют оттолкнуться 
                                                //от абсолютно любого элемента на странице
//получим РОДИТЕЛЕЙ, СОСЕДЕЙ и ДЕТЕЙ
//вот стандартный метод получения элемента пускай будет по id
document.querySelector(`#current`);
//а теперь можно попробовать вытащить его родителя(там 2 метода но возьмём пока paretnNode)
console.log(document.querySelector(`#current`).parentElement);//получим элемент first
//самое прикольное мы можем получить Родителя, родилетя
console.log(document.querySelector(`#current`).parentElement.parentElement);//получим элемент wrapper

//parentNode если его использовать то можно получить текствую ноду вместо элемента

                                                //data - атрибут появился в ies5 стандарте
/* например у нас есть вот такая строчка в html
<li data-current="3">3</li>

data - это обязательное название для data-атрибута
current - это уже наше название можем чё угодно вместо current писать
и устанавливаем ему любое значение ="3"

ЗАЧЕМ ОНО надо? На data-атрибуты удобно ориентироваться, конечно можно ставить id но если их много
то с ними будет целый ворох проблем, а вот с data-атрибутами работать будет удобнее.
получение атрибута будет выглядеть так
*/
console.log(document.querySelector(`[data-current="3"]`));

//мы так же можем получить следующий элемент у нашего data-атрибута
//p.s не используй nextSibling иначе получим текстовую ноду переноса строки
console.log(document.querySelector(`[data-current="3"]`).nextElementSibling);

//предыдущий элемент
console.log(document.querySelector(`[data-current="3"]`).previousElementSibling);


                                                        //как УБРАТЬ текстовые ноды
//у нас есть метод
document.body.childNodes;
//в нём мы получаем все элемнты включая бесполезные текстовые ноды.
//их можно убрать через цикл
//у всех наших элементов есть ствойство nodeName(это по сути  тип данных). Если нам попадается текстовый узел
//то nodeName: "#text"  мы можем этим воспользоваться
//мы не будем создавать массив и вносить в него элементы, просто осортируем чреез console.log
console.log(`очищенный childNodes`);
for (const node of document.body.childNodes) 
{
    if(node.nodeName == `#text`)
    {
        continue;
    }

    console.log(node);
}
//метод неплох, но упаси боже если в элементе будет какой нибудь комментарий, мы его так же получим в нашем массиве