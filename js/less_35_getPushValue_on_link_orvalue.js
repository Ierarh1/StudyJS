//числа, строки, логические значени. Они передаются по значению
let a = 5;
let b = a;

b = b+22;
console.log(a);//=5
console.log(b);//=27

//собственно адекватная передача значения, а что будет если мы будем работать с такими же переменными но уже
//находящихся в объекте
const ValueTest = {
     a: 55,
     b:21
};

const CopyValue = ValueTest; 
CopyValue.a = 222221; //мы изменили значение a только в одном объекте. Но тк как объекты передаются
//по ссылке то поменяется оба значения
console.log(ValueTest); //  тут а = 222221
console.log(CopyValue); //и тут а = 222221

                                        //глубокие/поверхностные копии
//Разница между поверхностными и глубокими копиями заключается в том что при глубокой копии копируется абсолютно
//все значенияя как ОТДЕЛЬНЫЕ элементы,  а вот при поверхностной получается гибрид, значения копируются отдельными копиями
//а вот если существует вложенный объект то он будет скопирован по ссылке

//создадим функцию для копирования(копия будет поверхностной)
function copy(mainObj)
{
     let ObjCopy = {};
     let key;
     for(key in mainObj)
     {
          ObjCopy[key] = mainObj[key];
     }
     return ObjCopy;
}

const mainObj ={
     a:21,
     obj: {
          first: 1,
          second: 2
     }
};

let testCopyObj = copy(mainObj);

mainObj[`a`] = 42;

console.log(mainObj);//в первом а=42
console.log(testCopyObj)//тут а = 21, и это адекватное поеведение

//однаком если попробуем изменить вложенный объекты например first
mainObj[`obj`][`first`] = 244;

console.log(mainObj);//тут ожидаемо 244
console.log(testCopyObj)//а тут так же 244, хотя по логике должно быть 1, но тк как значение копирнулось по
//ссылке то получается гибридная хрень  где половина значений скопированна по сссылке а вторая по значению

                                   //добавить один объект в другой Object.assign()  
//по сути это получится ПОВЕРХНОСТНАЯ копия одного объекта в друго 
const add = {
     d: 17,
     e:22
};

const first = {
     a:25,
     lr:17
};
//1 аргумент куда мы помещаем
//2 аргумент что мы помещаем
Object.assign(first,add);
console.log(first);//вуаля мы слилил все объект add и first, в одну кучу в first
//вместо 1 объекта можно тупо загнать пустой объект  Object.assign({},add); и будет нормально

                                   ///МАссивы ПОВЕРХНОСТНАЯ копия
const oldArr = [2,5,6,70];
const newArr = oldArr.slice();
//p.s если сделать вот так const newArr = oldArr          без slice(); то мы тупо передадим ссылку

//убедимся что это поверхнотные копии
newArr[1] = `ssss`;
console.log(oldArr);
console.log(newArr);

                                   //spread- оператор(оператор разворота) это ... перед переменной
//суть в том что этот оператор сам развенёт массивы и впишет их в новый, нам не прийдётся самим городить иъ черец циклы
//и прочую хрень просто ставим ... переж необходимым элементом и ператор сам их развернёт и впишет
const video = [`youtube`,`vimeo`,`rutube`],
      blogs = [`wordpres`,`livejournal`,`blogger`],
   internet =  [...video, ...blogs, `test`,`end_mass`];

console.log(internet);

//ещё один вариант использования. К примеру нам от сайта пришёл массив/псевдомассив, и на мего надо передать в функцию
//вместо того что бы городить циклы можем овспользоваться ... оператором

//есть вот такая функция в неё нужно впихнуть ответ пользователя
function log(a,b,c)
{
     console.log(a);
     console.log(b);
     console.log(c);
};

//а нам пришло вот это 
const num = [`www.youtube.com`,`server-new\\ng-55\\21`,`true`];

//мы можем развернуть её вот так
log(...num);

//так же мы можем использовать spread оператор для созданиия поверхностных копий 
const arrTest = [`a`,`b`];
const arrCopy = [...arrTest];
arrTest[1] = `TESTTTTT`;
console.log(arrCopy);
console.log(arrTest);

//так же оно работает и с объектами
const objectOLD = {
     one: 1,
     two: 2
};

const objectNEW = {...objectOLD};
console.log(objectNEW);